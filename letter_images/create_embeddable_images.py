#! /usr/bin/env python3

# This file compresses all .png files in this file
# and stores as c code so we can embedd it in uC such Arduino
# Note! Image width and height must match screen size
from PIL import Image
from pathlib import Path

dir_path = Path(__file__).absolute().parent

# create a cfile and a h file
with open(dir_path / "images.c", encoding="utf8", mode="w") as c_file,\
     open(dir_path / "images.h", encoding="utf8", mode="w") as h_file:
    
    h_file.write("""
// This is an autogenerated file, edit at your own peril.
#ifndef IMAGES_H
#define IMAGES_H
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

// This is a compressed version to save space. 
// Store length of consecuatly same pixel value.
// When rendering we render that many pixels of that color.
struct vlu_seg {
  uint16_t len; // How many consecuetive pixels of ths same color.
  uint8_t vlu;  // What pixel value to render.
};
 
/// An image is a collection of vlu_seg segments.
struct vlu_img {
  const struct vlu_seg* segs; // The segments this image contains
  uint16_t n_segs;      // Number of segments in this image.
};

///Function pointer to a function that send 1 byte to screen
typedef void (*images_send_data)(uint8_t byt);

/// The actual decompress and render function
int images_render(
    const struct vlu_img* img,
    const images_send_data send_fn,
    const uint32_t max_pixels);
""")
    c_file.write("""
// This is an autogenerated file, edit at your own peril.

#include \"images.h\" 
                 
int images_render(
    const struct vlu_img* img,
    const images_send_data send_fn,
    const uint32_t max_pixels) 
{
  uint32_t pixel_cnt = 0;
  uint8_t byt = 0, p = 0;
  for (uint16_t i = 0; i < img->n_segs; i++) {
    for (uint16_t j = 0; j < img->segs[i].len; j++) {
      if (max_pixels < ++pixel_cnt)
        return 0;

      // rebuild the byte (8 pixels)
      byt |= img->segs[i].vlu << (7-p);
      if (8 == ++p) { 
        // send in chunks of 8 bits
        send_fn(byt);
        byt = p = 0;
      }
    }
  }
}

""")

    for filename in dir_path.iterdir():
        if not filename.suffix == '.png':
            continue
        name = filename.name.lower() \
                .replace(' ', '_') \
                .replace('å', 'a') \
                .replace('ä', 'a') \
                .replace('ö', 'o') 
        fname = filename.stem
        with Image.open(dir_path / name) as img:

            pixels = img.load()
            w,h = img.size
            vluLen = 0
            vlus = []
            vlu = 0
            for y in range(h):
                for x in range(w):
                    # compress it
                    pix_vlu = 1 if pixels[x,y] else 0
                    if pix_vlu != vlu or vluLen == 65535:
                        if vluLen:
                            vlus.append((vlu, vluLen))
                        vluLen = 0
                        vlu = pix_vlu
                    vluLen += 1
                
            if vluLen:
                vlus.append((vlu, vluLen))
            h_file.write(f"\nextern const struct vlu_img {fname};\n")
                
            c_file.write(f"""
/// File: {filename.name}
static const struct vlu_seg {fname}_segs[{len(vlus)}] = """ + "{\n")
            for seg in vlus:
                c_file.write(f"  {{.len = {seg[1]}, .vlu = {seg[0]}}},\n")   
            c_file.write("};\n")
            c_file.write(f"""
const struct vlu_img {fname} = {{
    .segs = {fname}_segs,
    .n_segs = {len(vlus)}
    }};
    """)

    h_file.write("""

#ifdef __cplusplus
} // extern "C"
#endif

#endif // IMAGES_H
""")